Package br.com.ufs.pascalito;

Helpers 
    digito = ['0' .. '9'];
    letra = ['a' .. 'z'] | ['A' .. 'Z'];
    tab = 9;
    cr = 13;
    lf = 10;
    eol = cr lf | cr | lf;
    blank = (' ' | tab | eol)+;
    ascii = [0 .. 0x7F];
    ascii_sem_newline = [ascii - [cr + lf]];
    ascii_sem_asterisco = [ascii - '*'];
    ascii_sem_asterico_barra = [ascii_sem_asterisco - '/'];
    ascii_sem_aspa_simples_newline = [ascii_sem_newline - '''];
    
    coment_linha = '//' ascii_sem_newline* eol;
    coment_bloco_inicio = '/*';
    
    a = 'a' | 'A';
	b = 'b' | 'B';
	c = 'c' | 'C';
	d = 'd' | 'D';
	e = 'e' | 'E';
	f = 'f' | 'F';
	g = 'g' | 'G';
	h = 'h' | 'H';
	i = 'i' | 'I';
	j = 'j' | 'J';
	k = 'k' | 'K';
	l = 'l' | 'L';
	m = 'm' | 'M';
	n = 'n' | 'N';
	o = 'o' | 'O';
	p = 'p' | 'P';
	q = 'q' | 'Q';
	r = 'r' | 'R';
	s = 's' | 'S';
	t = 't' | 'T';
	u = 'u' | 'U';
	v = 'v' | 'V';
	w = 'w' | 'W';
	x = 'x' | 'X';
	y = 'y' | 'Y';
	z = 'z' | 'Z';
    
States
	normal,
	comment;

Tokens
{normal}    integer = i n t e g e r;
{normal}    string = s t r i n g;
{normal}    real = r e a l;
{normal}    boolean = b o o l e a n;
{normal}    array = a r r a y;
{normal}    if = i f;
{normal}    then = t h e n;
{normal}    else = e l s e;
{normal}    while = w h i l e;
{normal}    for = f o r;
{normal}    case = c a s e;
{normal}    of = o f;
{normal}    begin = b e g i n;
{normal}    end = e n d;
{normal}    program = p r o g r a m;
{normal}    var = v a r;
{normal}	function = f u n c t i o n;
{normal}	label = l a b e l;
{normal}	procedure = p r o c e d u r e;
{normal}	do = d o;
{normal}	type = t y p e;

{normal}	const_booleana = t r u e | f a l s e;
{normal}    identificador = letra (letra | digito)*;
{normal}	ponto_e_virgula = ';';
{normal}	ponto = '.';
{normal}	ponto_ponto = '..';
{normal}	abre_parenteses = '(';
{normal}	fecha_parenteses = ')';
{normal}	virgula = ',';
{normal}	atribuicao = ':=';
{normal}	dois_pontos = ':';
{normal}	abre_colchete = '[';
{normal}	fecha_colchete = ']';
{normal}	const_inteiro = digito digito*;
{normal}	const_real = digito* '.' digito digito* (e ('+' | '-')? digito digito*)?;
{normal}    blank = blank;
{normal}    const_string = ''' ascii_sem_aspa_simples_newline* ''';
{normal}	operador_relacional = '<' | '>' | '<=' | '>=' | '<>';
{normal}	igual = '=';
{normal}	not = n o t;
{normal}	operador_aditivo = '+' | '-' | o r;
{normal}	operador_multiplicativo = '*' | '/' | d i v | m o d | a n d;

{normal}	coment_linha = coment_linha;

{normal->comment, comment}	coment_bloco = coment_bloco_inicio;
{comment, normal}	coment_bloco_fim = '*/';
{comment}	coment_bloco_corpo = ascii_sem_asterico_barra*;
{comment}	asterico = '*';
{comment}	barra = '/';

Ignored Tokens
	blank,
	coment_bloco,
	coment_linha;
	
Productions
	program = cabecalho_programa ponto_e_virgula bloco ponto;
	cabecalho_programa = {unico} T.program identificador | {multiplo} T.program identificador abre_parenteses identificadores fecha_parenteses;
	bloco = declaracao_labels declaracao_tipos declaracoes_variaveis declaracoes_proc_funcoes sentenca_composta;
	
	identificadores = {unico} identificador | {multiplo} identificadores virgula identificador;
	identificador_tipo_ordinal = {integer} integer | {string} string | {real} real | {boolean} boolean;
	identificador_tipo = {identificador} identificador | {ordinal} identificador_tipo_ordinal;
	
	declaracao_labels = T.label labels ponto_e_virgula | {empty};
	labels = {unico} P.label | {multiplo} labels virgula P.label;
	label = const_inteiro;
	
	declaracao_tipos = type definicao_tipos ponto_e_virgula | {empty};
	definicao_tipos = {unico} identificador igual denotador_tipo | {multiplo} definicao_tipos virgula denotador_tipo;
	denotador_tipo = {existente} identificador | {novo} novo_tipo | {ordinal} identificador_tipo_ordinal;
	novo_tipo = {ordinal} novo_tipo_ordinal | {array} tipo_array;
	tipo_array = array abre_colchete tipos_ordinais fecha_colchete of denotador_tipo;
	tipos_ordinais = {unico} tipo_ordinal | {multiplo} tipos_ordinais virgula tipo_ordinal;
	tipo_ordinal = {novo} novo_tipo_ordinal | {existente} identificador;
	novo_tipo_ordinal = {enumerado} tipo_enumerado | {subrange} tipo_subrange;
	tipo_enumerado = abre_parenteses identificadores fecha_parenteses;
	tipo_subrange = [inicio]:constante ponto_ponto [fim]:constante;
	
	constante = {inteiro} const_inteiro | {string} const_string;
	
	declaracoes_variaveis = var declaracao_variaveis ponto_e_virgula | {empty};
	declaracao_variaveis = {unico} declaracao_variavel | {multiplo} declaracao_variaveis ponto_e_virgula declaracao_variavel;
	declaracao_variavel = identificadores dois_pontos denotador_tipo;
	
	declaracoes_proc_funcoes = declaracao_proc_funcoes | {empty};
	declaracao_proc_funcoes = {unico} declaracao_proc_funcao | {multiplo} declaracao_proc_funcoes declaracao_proc_funcao;
	declaracao_proc_funcao = {procedure} declaracao_procedure ponto_e_virgula | {funcao} declaracao_funcao ponto_e_virgula;
	declaracao_procedure = cabecalho_procedure ponto_e_virgula bloco;
	declaracao_funcao = cabecalho_funcao ponto_e_virgula bloco;
	
	cabecalho_procedure = procedure identificador parametros_formais;
	cabecalho_funcao = function identificador parametros_formais dois_pontos tipo_resultado;
		
	parametros_formais = abre_parenteses secao_parametros_formais fecha_parenteses | {empty};
	secao_parametros_formais = {unico} secao_parametro_formal | {multiplo} secao_parametros_formais ponto_e_virgula secao_parametro_formal;
	secao_parametro_formal = {valor} spec_param_valor | {variavel} spec_param_variavel | {array} spec_param_array;
	
	spec_param_valor = identificadores dois_pontos identificador_tipo;
	spec_param_variavel = var identificadores dois_pontos identificador_tipo;
	spec_param_array = {valor} spec_param_array_valor | {variavel} spec_param_array_variavel;
	spec_param_array_valor = identificadores dois_pontos schema_array;
	spec_param_array_variavel = var identificadores dois_pontos schema_array;
	schema_array = array abre_colchete spec_tipos_indices fecha_colchete of abre_parenteses identificador_schema_array fecha_parenteses;
	spec_tipos_indices = {unico} spec_tipo_indice | {multiplo} spec_tipos_indices ponto_e_virgula spec_tipo_indice;
	spec_tipo_indice = [inicio]:identificador ponto_ponto [fim]:identificador dois_pontos identificador_tipo_ordinal;
	identificador_schema_array = {identificador} identificador | {array} schema_array;
	
	tipo_resultado = {existente} identificador | {ordinal} identificador_tipo_ordinal;
	
	sentenca_composta = begin sequencia_sentencas end;
	sequencia_sentencas = {unico} sentenca | {multiplo} sequencia_sentencas ponto_e_virgula sentenca;
	sentenca = label_sentenca definicao_sentenca;
	label_sentenca = P.label dois_pontos | {empty};
	definicao_sentenca = {simples} sentenca_simples | {estruturada} sentenca_estruturada;
	
	sentenca_simples = {atribuicao} sentenca_atribuicao | {procedure} sentenca_procedure | {empty};
	sentenca_atribuicao = acesso_variavel atribuicao expressao;
	
	sentenca_procedure = procedure identificador parametros_reais;
	parametros_reais = abre_parenteses definicao_parametros_reais fecha_parenteses | {empty};
	definicao_parametros_reais = {unico} parametro_real | {multiplo} definicao_parametros_reais virgula parametro_real;
	parametro_real = {expressao} expressao | {variavel} acesso_variavel;
	
	sentenca_estruturada = sentenca_composta;
	
	acesso_variavel = identificador | {indexada} variavel_indexada;
	variavel_indexada = acesso_variavel abre_colchete expressoes fecha_colchete;
	expressoes = {unico} expressao | {multiplo} expressoes virgula expressao;
	
	expressao = expressao_simples expressao_relacional;
	expressao_relacional = operador_relacional expressao_simples | {empty};
	expressao_simples = termo expressoes_aditivas;
	expressoes_aditivas = {unico} termo | {multiplo} operador_aditivo termo;
	termo = {inteiro} const_inteiro | {real} const_real;
	