Package br.com.ufs.pascalito;

Helpers 
    digito = ['0' .. '9'];
    letra = ['a' .. 'z'] | ['A' .. 'Z'];
    tab = 9;
    cr = 13;
    lf = 10;
    eol = cr lf | cr | lf;
    blank = (' ' | tab | eol)+;
    ascii = [0 .. 0x7F];
    aspa_simples = ''';
    ascii_sem_newline = [ascii - [cr + lf]];
    ascii_sem_asterisco = [ascii - '*'];
    ascii_sem_asterico_barra = [ascii_sem_asterisco - '/'];
    ascii_sem_aspa_simples_newline = [ascii_sem_newline - aspa_simples];
    
    
    coment_linha = '//' ascii_sem_newline* eol;
    coment_bloco_inicio = '/*';
    
    a = 'a' | 'A';
	b = 'b' | 'B';
	c = 'c' | 'C';
	d = 'd' | 'D';
	e = 'e' | 'E';
	f = 'f' | 'F';
	g = 'g' | 'G';
	h = 'h' | 'H';
	i = 'i' | 'I';
	j = 'j' | 'J';
	k = 'k' | 'K';
	l = 'l' | 'L';
	m = 'm' | 'M';
	n = 'n' | 'N';
	o = 'o' | 'O';
	p = 'p' | 'P';
	q = 'q' | 'Q';
	r = 'r' | 'R';
	s = 's' | 'S';
	t = 't' | 'T';
	u = 'u' | 'U';
	v = 'v' | 'V';
	w = 'w' | 'W';
	x = 'x' | 'X';
	y = 'y' | 'Y';
	z = 'z' | 'Z';
    
States
	normal,
	comment,
	string;

Tokens
{normal}    integer = i n t e g e r;
{normal}    string = s t r i n g;
{normal}    boolean = b o o l e a n;
{normal}    array = a r r a y;
{normal}    if = i f;
{normal}    then = t h e n;
{normal}    else = e l s e;
{normal}    while = w h i l e;
{normal}    for = f o r;
{normal}    case = c a s e;
{normal}    of = o f;
{normal}    begin = b e g i n;
{normal}    end = e n d;
{normal}    program = p r o g r a m;
{normal}    var = v a r;
{normal}	function = f u n c t i o n;
{normal}	label = l a b e l;
{normal}	procedure = p r o c e d u r e;
{normal}	do = d o;
{normal}	type = t y p e;
{normal}	goto = g o t o;

{normal}	const_booleana = t r u e | f a l s e;
{normal}	and = a n d;
{normal}	or = o r;
{normal}	div = d i v;
{normal}	mod = m o d;
{normal}	not = n o t;
{normal}    identificador = letra (letra | digito)*;
{normal}	ponto_e_virgula = ';';
{normal}	ponto = '.';
{normal}	ponto_ponto = '..';
{normal}	abre_parenteses = '(';
{normal}	fecha_parenteses = ')';
{normal}	virgula = ',';
{normal}	atribuicao = ':=';
{normal}	dois_pontos = ':';
{normal}	abre_colchete = '[';
{normal}	fecha_colchete = ']';
{normal}	const_inteiro = digito digito*;
{normal}    blank = blank;
{normal}	menor = '<';
{normal}	menor_igual = '<=';
{normal}	maior = '>';
{normal}	maior_igual = '>=';
{normal}	diferente = '<>';
{normal}	igual = '=';
{normal}	soma = '+';
{normal}	subtracao = '-';
{normal}	multiplicacao = '*';
{normal}	divisao = '/';

{normal}	coment_linha = coment_linha;

{normal->comment, comment}	coment_bloco = coment_bloco_inicio;
{comment, normal}	coment_bloco_fim = '*/';
{comment}	coment_bloco_corpo = ascii_sem_asterico_barra*;
{comment}	asterico = '*';
{comment}	barra = '/';

{normal->string}    const_string = aspa_simples;
{string}	const_string_corpo = ascii_sem_aspa_simples_newline*;
{string}	aspa_simples = aspa_simples;
{string}	newline = eol;

Ignored Tokens
	blank,
	coment_bloco,
	coment_linha;
	
Productions
	program {-> P.program} = {unico} T.program identificador ponto_e_virgula bloco ponto {-> New program(New string(identificador), [], bloco) }
		| {multiplo} T.program identificador abre_parenteses identificadores fecha_parenteses ponto_e_virgula bloco ponto {-> New program(New string(identificador), [identificadores.string], bloco) };
	
	bloco {-> P.bloco} = declaracao_labels declaracao_tipos declaracoes_variaveis declaracoes_proc_funcoes sentenca_composta 
		{-> New bloco([declaracao_labels.numero_sem_sinal], [declaracao_tipos.definicao_tipo]) };
	
	identificadores {-> P.string*} = {unico} identificador {-> [New string(identificador)]} 
		| {multiplo} identificadores virgula identificador {-> [identificadores.string, New string(identificador)]};
	
	identificador_tipo_ordinal {-> tipo_primitivo} = {integer} integer {-> New tipo_primitivo.integer(integer)} 
		| {string} string {-> New tipo_primitivo.string(T.string)} 
		| {boolean} boolean {-> New tipo_primitivo.boolean(boolean)};
	
	identificador_tipo = {identificador} identificador | {ordinal} identificador_tipo_ordinal;
	
	declaracao_labels {-> P.numero_sem_sinal*} = T.label labels ponto_e_virgula {-> [labels.numero_sem_sinal]}
		| {empty} {-> []};
		
	labels {-> P.numero_sem_sinal*} = {unico} P.label {-> [label.numero_sem_sinal]} 
		| {multiplo} labels virgula P.label {-> [label.numero_sem_sinal, labels.numero_sem_sinal]};
		
	label {-> P.numero_sem_sinal} = const_inteiro {-> New numero_sem_sinal(const_inteiro) };
	
	declaracao_tipos {-> definicao_tipo*} = type definicao_tipos ponto_e_virgula {-> [definicao_tipos.definicao_tipo]} 
		| {empty} {-> []};
	
	definicao_tipos {-> definicao_tipo*} = {unico} definicao_tipo {-> [definicao_tipo]} 
		| {multiplo} definicao_tipos ponto_e_virgula definicao_tipo {-> [definicao_tipo, definicao_tipos.definicao_tipo] };
	
	definicao_tipo {-> definicao_tipo} = identificador igual denotador_tipo {-> New definicao_tipo(New string(identificador), denotador_tipo) };
	
	denotador_tipo {-> denotador_tipo} = {existente} identificador {-> New denotador_tipo.id_ou_ordinal(New tipo_id_ou_ordinal.id(New tipo_identificador(New string(identificador))))}
		| {ordinal} identificador_tipo_ordinal {-> New denotador_tipo.primitivo(identificador_tipo_ordinal.tipo_primitivo) };
	
	novo_tipo = {ordinal} novo_tipo_ordinal | {array} tipo_array;
	tipo_array {-> tipo_array} = array abre_colchete tipos_ordinais fecha_colchete of denotador_tipo {-> New tipo_array([tipos_ordinais.tipo_id_ou_ordinal], denotador_tipo)};
	
	tipos_ordinais {-> tipo_id_ou_ordinal*} = {unico} tipo_ordinal {-> [tipo_ordinal.tipo_id_ou_ordinal]}
		| {multiplo} tipos_ordinais virgula tipo_ordinal {-> [tipo_ordinal.tipo_id_ou_ordinal, tipos_ordinais.tipo_id_ou_ordinal]};
		
	tipo_ordinal {-> tipo_id_ou_ordinal} = {novo} novo_tipo_ordinal {-> novo_tipo_ordinal.tipo_id_ou_ordinal} 
		| {existente} identificador {-> New tipo_id_ou_ordinal.id(New tipo_identificador(New string(identificador)))};
		
	novo_tipo_ordinal {-> tipo_id_ou_ordinal} = {enumerado} tipo_enumerado {-> New tipo_id_ou_ordinal.enumerado(tipo_enumerado)}
		| {subrange} tipo_subrange {-> New tipo_id_ou_ordinal.subrange(tipo_subrange)};
		
	tipo_enumerado {-> tipo_enumerado} = abre_parenteses identificadores fecha_parenteses {-> New tipo_enumerado([identificadores.string])};
	
	tipo_subrange {-> tipo_subrange} = [inicio]:constante ponto_ponto [fim]:constante {-> New tipo_subrange(inicio, fim) };
	
	sinal {-> sinal} = {soma} soma {-> New sinal.mais(soma)} 
		| {subtracao} subtracao {-> New sinal.menos(subtracao)};
	
	constante {-> constante} = {numero} sinal? const_inteiro {-> New constante.inteiro(sinal, const_inteiro)} 
		| {string} const_string {-> New constante.string(const_string) }
		| {boolean} const_booleana {-> New constante.boolean(const_booleana) };
	
	constante_sem_sinal {-> constante} = {numero} const_inteiro {-> New constante.inteiro(Null, const_inteiro) } 
		| {string} const_string {-> New constante.string(const_string) }
		| {boolean} const_booleana {-> New constante.boolean(const_booleana) };
	
	declaracoes_variaveis = var declaracao_variaveis ponto_e_virgula | {empty};
	declaracao_variaveis = {unico} declaracao_variavel | {multiplo} declaracao_variaveis ponto_e_virgula declaracao_variavel;
	declaracao_variavel = identificadores dois_pontos denotador_tipo;
	
	declaracoes_proc_funcoes = declaracao_proc_funcoes | {empty};
	declaracao_proc_funcoes = {unico} declaracao_proc_funcao | {multiplo} declaracao_proc_funcoes declaracao_proc_funcao;
	declaracao_proc_funcao = {procedure} declaracao_procedure ponto_e_virgula | {funcao} declaracao_funcao ponto_e_virgula;
	declaracao_procedure = cabecalho_procedure ponto_e_virgula bloco;
	declaracao_funcao = cabecalho_funcao ponto_e_virgula bloco;
	
	cabecalho_procedure = procedure identificador parametros_formais;
	cabecalho_funcao = function identificador parametros_formais dois_pontos tipo_resultado;
		
	parametros_formais = abre_parenteses secao_parametros_formais fecha_parenteses | {empty};
	secao_parametros_formais = {unico} secao_parametro_formal | {multiplo} secao_parametros_formais ponto_e_virgula secao_parametro_formal;
	secao_parametro_formal = {valor} spec_param_valor | {variavel} spec_param_variavel | {array} spec_param_array;
	
	spec_param_valor = identificadores dois_pontos identificador_tipo;
	spec_param_variavel = var identificadores dois_pontos identificador_tipo;
	spec_param_array = {valor} spec_param_array_valor | {variavel} spec_param_array_variavel;
	spec_param_array_valor = identificadores dois_pontos schema_array;
	spec_param_array_variavel = var identificadores dois_pontos schema_array;
	schema_array = array abre_colchete spec_tipos_indices fecha_colchete of abre_parenteses identificador_schema_array fecha_parenteses;
	spec_tipos_indices = {unico} spec_tipo_indice | {multiplo} spec_tipos_indices ponto_e_virgula spec_tipo_indice;
	spec_tipo_indice = [inicio]:identificador ponto_ponto [fim]:identificador dois_pontos identificador_tipo_ordinal;
	identificador_schema_array = {identificador} identificador | {array} schema_array;
	
	tipo_resultado = {existente} identificador | {ordinal} identificador_tipo_ordinal;
	
	sentenca_composta = begin sequencia_sentencas end;
	sequencia_sentencas = {unico} sentenca | {multiplo} sequencia_sentencas ponto_e_virgula sentenca;
	sentenca = {simples} definicao_sentenca_simples | {estruturada} definicao_sentenca_estruturada;
	label_sentenca = P.label dois_pontos | {empty};
	
	definicao_sentenca = {simples} definicao_sentenca_simples | {estruturada} definicao_sentenca_estruturada | {estruturada_fechada} definicao_sentenca_estruturada_fechada;
	definicao_sentenca_fechada = {simples} definicao_sentenca_simples | {estruturada} definicao_sentenca_estruturada_fechada;
	definicao_sentenca_simples = label_sentenca sentenca_simples;
	definicao_sentenca_estruturada = label_sentenca sentenca_estruturada;
	definicao_sentenca_estruturada_fechada = label_sentenca sentenca_estruturada_fechada;
	
	sentenca_simples = {atribuicao} sentenca_atribuicao | {procedure} sentenca_proc_funcao | {goto} sentenca_goto | {empty};
	sentenca_atribuicao = acesso_variavel atribuicao expressao;
	
	sentenca_proc_funcao = identificador parametros_reais;
	parametros_reais = abre_parenteses definicao_parametros_reais fecha_parenteses | {empty};
	definicao_parametros_reais = {unico} expressao | {multiplo} definicao_parametros_reais virgula expressao;
	
	sentenca_estruturada = {composta} sentenca_composta | {while} sentenca_while | {if} sentenca_if;
	sentenca_estruturada_fechada = {composta} sentenca_composta | {while} sentenca_while_fechada;
	
	sentenca_while = while expressao do definicao_sentenca_simples | {estruturada} while expressao do definicao_sentenca_estruturada;
	sentenca_while_fechada = while expressao do definicao_sentenca_fechada;
	
	sentenca_goto = goto P.label;
	
	sentenca_if = if expressao then sentenca | {else} if expressao then sentenca_if_fechada else sentenca;
	sentenca_if_fechada = {if} if expressao then [parte_if]:sentenca_if_fechada else sentenca_if_fechada | definicao_sentenca_fechada;
	
	acesso_variavel = identificador | {indexada} variavel_indexada;
	variavel_indexada = acesso_variavel abre_colchete expressoes fecha_colchete;
	expressoes = {unico} expressao | {multiplo} expressoes virgula expressao;
	
	expressao = expressao_simples expressao_relacional;
	expressao_relacional = operador_relacional expressao_simples | {empty};
	expressao_simples = {unico_com_sinal} sinal+ termo | {unico_sem_sinal} termo | {multiplo_sem_sinal} expressao_simples operador_aditivo termo | {multiplo_com_sinal} expressao_simples operador_aditivo sinal+ termo;
	termo = {unico} fator | {multiplo} termo operador_multiplicativo fator;
	fator = {constante_sem_sinal} constante_sem_sinal | {expressao} abre_parenteses expressao fecha_parenteses | {not} not fator | {funcao_ou_variavel} sentenca_proc_funcao | {var_indexada} variavel_indexada;
	operador_relacional = {menor} menor | {menor_igual} menor_igual | {maior} maior | {maior_igual} maior_igual | {igual} igual | {diferente} diferente;
	operador_aditivo = {soma_sub} sinal | {or} or;
	operador_multiplicativo = {multiplicacao} multiplicacao | {divisao} divisao | {and} and | {div} div | {mod} mod;
	
Abstract Syntax Tree
	program = [id]:P.string [ids]:P.string* bloco;
	string = identificador;
	constante = {inteiro} P.sinal? const_inteiro | {string} const_string | {boolean} const_booleana;
	bloco = numero_sem_sinal* definicao_tipo*;
	numero_sem_sinal = const_inteiro;
	
	definicao_tipo = P.string denotador_tipo;
	denotador_tipo = {primitivo} tipo_primitivo | {id_ou_ordinal} tipo_id_ou_ordinal | {array} tipo_array;
	tipo_primitivo = {integer} integer | {string} T.string | {boolean} boolean;
	tipo_id_ou_ordinal = {id} tipo_identificador | {enumerado} tipo_enumerado | {subrange} tipo_subrange;
	tipo_identificador = P.string;
	tipo_enumerado = P.string*;
	tipo_subrange = [inicio]:constante [fim]:constante;
	tipo_array = tipo_id_ou_ordinal+ denotador_tipo;
	sinal = {mais} soma | {menos} subtracao;